<!-- Robot Arm Control v4.3.1 (fix: define exportDiagnostics + parseQr) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lego Arm Control</title>
  <!-- Tailwind CDN for DEV. For production, compile Tailwind locally. -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { theme: { extend: { colors: {
      brand: { 25:"#f3f9ff",50:"#eaf3ff",100:"#d6e9ff",200:"#b6d9ff",300:"#8cc5ff",400:"#56aaff",500:"#1f90ff",600:"#1477db",700:"#0f5fb1",800:"#0c4d8f",900:"#0a3e75" }
    }}}};
  </script>
  <style>
    body { background: #f6f9fc; }
    .glass { background: rgba(255,255,255,0.18); border: 1px solid rgba(255,255,255,0.25); box-shadow: 0 8px 24px rgba(0,0,0,0.10); backdrop-filter: saturate(160%) blur(8px); }
    .soft-shadow { box-shadow: 0 14px 32px -8px rgba(2,132,199,.35); }
    .console-area { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .pressable { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; touch-action: none; }
    .no-select { -webkit-user-select: none; user-select: none; }
  </style>
</head>
<body class="antialiased text-slate-800">
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/qr-scanner@1.4.2/qr-scanner.umd.min.js"></script>

  <script type="text/babel">
    const {useEffect,useRef,useState,useMemo} = React;

    // ---------- Utils ----------
    const now = () => Date.now();
    const fmtMs = ms => (ms<1000? ms+'ms' : (ms/1000).toFixed(2)+'s');
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const join = (a,b) => {
      let s1 = String(a), s2 = String(b);
      while (s1.endsWith('/')) s1 = s1.slice(0,-1);
      while (s2.startsWith('/')) s2 = s2.slice(1);
      return s1 + '/' + s2;
    };
    const normalizeDeg = deg => ((deg + 180) % 360 + 360) % 360 - 180;
    const MOTOR_ORDER = ["A","B","C","D","E","F"];
    const POS_ORDER = {
      A:["open","closed"],
      B:["min","pick","max"],
      C:["min","pick","max"],
      D:["assembly","neutral","quality"],
    };
    const cx = (...classes) => classes.filter(Boolean).join(' ');

    function useLocalStorage(key, initial){
      const [v,setV]=useState(()=>{ try { return JSON.parse(localStorage.getItem(key)) ?? initial; } catch { return initial; } });
      useEffect(()=>{ localStorage.setItem(key, JSON.stringify(v)); }, [key, v]);
      return [v,setV];
    }

    function percentile(arr,p){
      if(arr.length===0) return 0;
      const s=[...arr].sort((a,b)=>a-b);
      const idx = Math.min(s.length-1, Math.max(0, Math.floor((p/100)*(s.length-1))));
      return s[idx];
    }

    // ---------- UI primitives ----------
    const Icon = ({name, className="w-5 h-5"}) => ({
      menu: <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M4 6h16M4 12h16M4 18h16"/></svg>,
      copy: <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="9" y="9" width="13" height="13" rx="2" strokeWidth="2"/><path strokeWidth="2" d="M5 15V5a2 2 0 012-2h10"/></svg>,
      trash:<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M3 6h18M8 6V4h8v2M6 6l1 14h10l1-14"/></svg>,
      play: <svg className={className} viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>,
      pause:<svg className={className} viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="5" width="4" height="14"/><rect x="14" y="5" width="4" height="14"/></svg>,
      plus: <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M12 5v14M5 12h14"/></svg>,
      qr:<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M3 3h8v8H3zM13 3h8v8h-8zM3 13h8v8H3zM16 13h2v2h-2zM20 13h1v6h-1zM16 17h3v1h-3z"/></svg>,
      console:<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M4 6h16v12H4z"/><path strokeWidth="2" d="M7 10l3 2-3 2M13 14h4"/></svg>,
      target:<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="8" strokeWidth="2"/><circle cx="12" cy="12" r="2" strokeWidth="2"/></svg>,
      stop:<svg className={className} viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>,
      dl:  <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M12 3v12m0 0l-4-4m4 4 4-4M4 21h16"/></svg>,
      tune:<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M4 6h10M14 6v10M4 18h16M8 18V8M18 6v8"/></svg>,
    }[name] || <span/>);

    const Btn = ({variant='primary', size='md', className='', children, ...props}) => {
      const sizes = {
        sm: 'px-2.5 py-1.5 text-sm rounded-lg',
        md: 'px-3 py-2.5 text-sm rounded-xl',
        lg: 'px-4 py-3 text-base rounded-xl',
        icon: 'w-14 h-14 rounded-full flex items-center justify-center'
      };
      const variants = {
        primary: 'bg-brand-600 hover:bg-brand-700 text-white border border-brand-700/20',
        secondary: 'bg-white hover:bg-slate-50 text-slate-700 border border-slate-200',
        ghost: 'bg-white/10 hover:bg-white/20 text-white border border-white/30',
        outline: 'bg-white text-slate-800 border border-slate-200',
        dark: 'bg-slate-800 text-white border border-slate-700',
        danger: 'bg-red-600 hover:bg-red-700 text-white border border-red-700/20',
      };
      return <button className={cx(sizes[size]||sizes.md, variants[variant]||variants.primary, className)} {...props}>{children}</button>;
    };

    const SectionHeader = ({title, subtitle, children}) => (
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-slate-800 font-semibold">{title}</h2>
          {subtitle && <div className="text-xs text-slate-500">{subtitle}</div>}
        </div>
        <div className="flex items-center gap-2">{children}</div>
      </div>
    );

    const Panel = ({title, subtitle, actions, children}) => (
      <section className="bg-white rounded-2xl shadow ring-1 ring-slate-100 p-4 sm:p-6">
        <SectionHeader title={title} subtitle={subtitle}>{actions}</SectionHeader>
        <div className="mt-4">{children}</div>
      </section>
    );

    const MotorPill = ({children, onClick}) => (
      <button onClick={onClick} className="glass inline-flex items-center gap-1 px-2 py-1 rounded-full text-white text-[11px] hover:bg-white/25 active:scale-[0.98] transition no-select">
        {children}
      </button>
    );

    const Sparkline = ({data, width=80, height=20, padding=2}) => {
      if(!data || data.length<2) return <svg width={width} height={height}></svg>;
      const min = Math.min(...data), max = Math.max(...data);
      const range = (max-min) || 1;
      const stepX = (width - 2*padding) / (data.length - 1);
      const pts = data.map((v,i)=>[padding + i*stepX, height - padding - ((v-min)/range)*(height-2*padding)]);
      const d = pts.map((p,i)=> (i===0? 'M':'L') + p[0].toFixed(1)+' '+p[1].toFixed(1)).join(' ');
      return <svg width={width} height={height}><path d={d} fill="none" stroke="currentColor" strokeWidth="1"/></svg>;
    };

    const DeltaGauge = ({delta, tol=1, size=68}) => {
      const r = (size/2)-6, cx=size/2, cy=size/2;
      const clamped = Math.abs(delta) > 90 ? 90 : Math.abs(delta);
      const angle = (clamped/90)*Math.PI;
      const x = cx + r*Math.cos(Math.PI - angle);
      const y = cy + r*Math.sin(Math.PI - angle);
      const path = `M ${cx-r} ${cy} A ${r} ${r} 0 0 1 ${x} ${y}`;
      const ok = Math.abs(delta) <= tol;
      return (
        <svg width={size} height={size} className="text-slate-300">
          <circle cx={cx} cy={cy} r={r} stroke="currentColor" strokeWidth="6" fill="none" opacity="0.25"/>
          <path d={path} stroke={ok?'#10b981':'#ef4444'} strokeWidth="6" fill="none" />
          <text x="50%" y="48%" dominantBaseline="middle" textAnchor="middle" fontSize="14" fill="#0f172a">{delta.toFixed(0)}°</text>
          <text x="50%" y="66%" dominantBaseline="middle" textAnchor="middle" fontSize="10" fill="#64748b">Δ</text>
        </svg>
      );
    };

    // ---------- App ----------
    function App(){
      // Single-robot config
      const [baseUrl, setBaseUrl] = useLocalStorage("ra.baseUrl", '');
      const [apiKey, setApiKey] = useLocalStorage("ra.apiKey", '');

      // Core state
      const [connected,setConnected]=useState(false);
      const [motors, setMotors] = useLocalStorage(
        "ra.motors",
        ["A","B","C","D"].map((n, i) => ({ id: i + 1, name: n, pos: 0 }))
      );
      const [logs,setLogs]=useLocalStorage("ra.logs",[]);
      const [inventory,setInventory]=useState(null);
      const [inventoryOpen,setInventoryOpen]=useState(false);
      const [adminOpen,setAdminOpen]=useState(false);
      const [qrOpen,setQrOpen]=useState(false);
      const [consoleOpen,setConsoleOpen]=useState(false);
      const [calibOpen,setCalibOpen]=useState(false);
      const [calibStatus,setCalibStatus]=useState({points:{},calibrated:false});
      const [backlash,setBacklash]=useState({A:0,B:0,C:0,D:0});
      const [lastDir,setLastDir]=useState({A:0,B:0,C:0,D:0});
      const [namedPoints,setNamedPoints]=useState({});
      const formattedPositions = useMemo(
        () =>
          motors
            .map(m => {
              const rot = ((m.abs ?? m.pos) / 360).toFixed(2).replace('.', ',');
              return `${m.name}: ${rot} rot`;
            })
            .join('\n'),
        [motors]
      );
      const formattedNamedPoints = useMemo(
        () => {
          const entries = Object.entries(namedPoints || {});
          if(entries.length===0) return 'No named points';
          return entries.map(([m,pts])=>{
            const inner = Object.entries(pts||{})
              .map(([n,v])=>`  ${n}: ${(+v).toFixed(1)}°`)
              .join('\n');
            return `${m}:\n${inner}`;
          }).join('\n');
        },
        [namedPoints]
      );

      // Pill action menu (J/C/B) state
      const [pillMenu,setPillMenu]=useState({open:false, motor:null, x:0, y:0});
      const pillMenuRef = useRef(null);

      // Ring buffer (2 min)
      const RING_MS = 120000;
      const [ring,setRing]=useLocalStorage("ra.ring", []);

      // Soft limits
      const [limits,setLimits]=useLocalStorage("ra.limits", {
        A:{min:-9999,max:9999},
        B:{min:-9999,max:9999},
        C:{min:-9999,max:9999},
        D:{min:-9999,max:9999}
      });

      // Teach poses
      const [taught,setTaught]=useLocalStorage("ra.taught", {});
      const [targetPose,setTargetPose]=useLocalStorage("ra.targetPose", null);

      // Production processes
      const [processes,setProcesses]=useState([]);

      // Offline queue
      const [offlineQueue,setOfflineQueue]=useLocalStorage("ra.offlineQueue", []);

      // Jog modal
      const [jogMotor,setJogMotor]=useState(null); // {id,name,pos}
      const [jogEnable,setJogEnable]=useState(false);
      const repeatRef = useRef(null);

      // Tilt-to-nudge (global permission; action gated by jogEnable + jogMotor)
      const [tiltEnabled,setTiltEnabled]=useState(false);
      const [tiltReady,setTiltReady]=useState(false);
      const [tiltGain,setTiltGain]=useLocalStorage("ra.tiltGain", 0.20);
      const [tiltBeta,setTiltBeta]=useState(0);
      const tiltZeroRef = useRef(0);
      const lastTiltTimeRef = useRef(0);

      // Custom
      const [customPath,setCustomPath]=useState("/v1/arm/move");
      const [customMethod,setCustomMethod]=useState("POST");
      const [customBody,setCustomBody]=useState('{"mode":"relative","joints":{"A":10},"speed":40}');
      const [nudgeUnit,setNudgeUnit]=useLocalStorage("ra.nudgeUnit","deg"); // 'deg' or 'rot'
      const [stepDeg,setStepDeg]=useLocalStorage("ra.stepDeg",5);
      const [stepRotRaw,setStepRotRaw]=useLocalStorage("ra.stepRot","1,0");
      const stepRotStr = String(stepRotRaw).replace('.', ',');
      const stepRot = parseFloat(stepRotStr.replace(',', '.')) || 0;
      const step = nudgeUnit==='deg' ? stepDeg : stepRot;

      const polling = useRef(false);
      const alive = useRef(true);
      useEffect(()=>()=>{ alive.current=false; },[]);

      // Pill menu outside click close
      useEffect(()=>{
        function onDocClick(e){
          if(!pillMenu.open) return;
          const el = pillMenuRef.current;
          if(el && !el.contains(e.target)){ setPillMenu({open:false, motor:null, x:0, y:0}); }
        }
        document.addEventListener('mousedown', onDocClick);
        return ()=>document.removeEventListener('mousedown', onDocClick);
      }, [pillMenu.open]);

      // --------- Logging helpers ---------
      const addLog = (e) => {
        const ts = new Date().toLocaleTimeString();
        setLogs(l=>[...l.slice(-999), {ts, ...e}]);
      };

      const headers = () => {
        const h={"Content-Type":"application/json","ngrok-skip-browser-warning":"1"};
        if(apiKey) h["x-api-key"]=apiKey;
        return h;
      };

      async function api(method, path, body, {timeoutMs=8000, queueIfOffline=false, log=true}={}){
        const url = join(baseUrl || "", path);
        if(queueIfOffline && !connected){
          const item={method,path,body,ts:now()}; setOfflineQueue(q=>[...q,item]);
          if(log) addLog({level:"ok",text:"Queued (offline): "+method+" "+url, body});
          return null;
        }
        const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(), timeoutMs);
        const opts={method, headers:headers(), signal:ctrl.signal};
        if(body!==undefined) opts.body=JSON.stringify(body);
        if(log) addLog({level:"req",text:`${method} ${url}`,body});
        const t0=performance.now();
        try{
          const res=await fetch(url, opts);
          const elapsed=Math.round(performance.now()-t0);
          const txt=await res.text(); let data=null; try{ data = txt ? JSON.parse(txt) : null; } catch {}
          if(log) addLog({level:res.ok?"ok":"err", text:`${res.status} ${res.statusText} (${elapsed}ms)`, body:(data??txt), ms:elapsed});
          if(!res.ok) throw new Error("HTTP "+res.status);
          return data?.data ?? data;
        } finally { clearTimeout(t); }
      }

      // Execute queued commands (explicit)
      async function runQueue(){
        if(!connected || offlineQueue.length===0) return;
        for(const item of offlineQueue){ await api(item.method, item.path, item.body).catch(()=>{}); }
        setOfflineQueue([]);
      }
      function clearQueue(){ setOfflineQueue([]); }

      async function saveBacklash(){
        try{ await api("POST","/v1/arm/backlash",backlash); addLog({level:"ok", text:"Saved backlash"}); }
        catch{ addLog({level:"err", text:"Failed to save backlash"}); }
      }

      // Calibration helpers
      async function fetchCalibration(){
        const d=await api("GET","/v1/arm/calibration",undefined,{log:false}).catch(()=>null);
        if(d) setCalibStatus(d);
      }
      async function setCalibPoint(joint,name){
        await api("POST","/v1/arm/calibration",{joint,name}).catch(()=>{});
        fetchCalibration();
      }
      async function finalizeCalibration(){
        const d=await api("POST","/v1/arm/calibration",{finalize:true}).catch(()=>null);
        if(d?.limits) setLimits(d.limits);
        if(d?.points) setCalibStatus({points:d.points, calibrated:true});
      }
      async function resetCalibration(){
        const d=await api("POST","/v1/arm/calibration",{reset:true}).catch(()=>null);
        if(d) setCalibStatus(d);
        setLimits({A:{min:-9999,max:9999},B:{min:-9999,max:9999},C:{min:-9999,max:9999},D:{min:-9999,max:9999}});
      }
      useEffect(()=>{ if(calibOpen) fetchCalibration(); },[calibOpen]);

      useEffect(()=>{
        if(adminOpen){
          api("GET","/v1/arm/backlash", undefined, {log:false})
            .then(d=>{
              setBacklash({A:0,B:0,C:0,D:0, ...(d?.backlash||{})});
              setLastDir({A:0,B:0,C:0,D:0, ...(d?.last_dir||{})});
            })
            .catch(()=>{});
        }
      }, [adminOpen]);

      // Health & state polling
      async function checkHealth(verbose=false){
        try{ await api("GET","/v1/health", undefined, {log:verbose}); setConnected(true); }
        catch{ setConnected(false); }
      }

      async function updatePositions(verbose=false){
        if(polling.current) return;
        polling.current = true;
        try{
          const s = await api("GET","/v1/arm/state", undefined, {log:verbose});
          if(s?.abs_degrees){
            const ordered = Object.entries(s.abs_degrees)
              .map(([k,v])=>({name:k,pos:normalizeDeg(+v),abs:+v}))
              .sort((a,b)=>MOTOR_ORDER.indexOf(a.name)-MOTOR_ORDER.indexOf(b.name))
              .map((m,i)=>({id:i+1,...m}));
            setMotors(ordered);
            const sample = { t: now(), angles: Object.fromEntries(ordered.map(m=>[m.name, m.pos])) };
            setRing(prev => {
              const arr = [...prev, sample];
              const cutoff = now() - RING_MS;
              return arr.filter(s => s.t >= cutoff);
            });
            setNamedPoints(s.points || {});
          }
        } finally { polling.current=false; }
      }

      async function loadInventory(show=false){
        const inv = await api("GET","/v1/inventory").catch(()=>null);
        if(show && inv){ setInventory(inv); setInventoryOpen(true); }
        return inv;
      }

      async function refreshProcesses(){
        const inv = await api("GET","/v1/inventory").catch(()=>null);
        if(inv){ setProcesses(inv.processes || []); }
      }

      async function runProcess(name){
        if(!name) return;
        await api("POST", `/v1/processes/${name}`, {}, {queueIfOffline:true}).catch(()=>{});
      }

      async function sendPose(name, speed=60){
        if(!name) return;
        await api("POST","/v1/arm/pose", {name, speed}, {queueIfOffline:true});
      }

      async function gotoNamed(joint, name, speed=60){
        if(!joint || !name) return;
        const joints={}; joints[joint]=name;
        await api("POST","/v1/arm/move",{mode:"absolute",joints,speed},{queueIfOffline:true}).catch(()=>{});
      }

      async function sendCoast(motorNames, enable=true){
        const body = {enable};
        if(motorNames){ body.motors = Array.isArray(motorNames) ? motorNames : [motorNames]; }
        await api("POST","/v1/arm/coast", body, {queueIfOffline:true}).catch(()=>{});
      }

      async function stop(){ await api("POST","/v1/arm/stop",{reason:"ui stop"},{queueIfOffline:true}).catch(()=>{}); }

      async function handleStop(){
        addLog({level:'req', text:'Stop requested'});
        stopHoldRepeat();
        setJogEnable(false);
        await stop();
      }

      // Degrees-based nudge
      async function nudge(name, deltaDeg, speed=60){
        const cur = normalizeDeg(motors.find(m=>m.name===name)?.pos ?? 0);
        const lim = limits[name] || {min:-9999,max:9999};
        const next = normalizeDeg(cur + deltaDeg);
        if(next < lim.min || next > lim.max){
          addLog({level:"err", text:`Soft limit ${name}: ${next.toFixed(1)}° out of [${lim.min}, ${lim.max}]`});
          return;
        }
        const joints={}; joints[name]=deltaDeg;
        await api("POST","/v1/arm/move",{mode:"relative",joints,speed},{queueIfOffline:true}).catch(()=>{});
        setMotors(p=>
          p.map(x =>
            x.name === name
              ? { ...x, pos: normalizeDeg(x.pos + deltaDeg), abs: (x.abs ?? x.pos) + deltaDeg }
              : x
          )
        );
      }

      async function refresh(verbose=false){ await updatePositions(verbose); }

      async function runTuner({joint="A", amplitude=5, speeds=[20,40,60,80], settleMs=350}){
        const results=[];
        for(const sp of speeds){
          const before = motors.find(m=>m.name===joint)?.pos ?? 0;
          await nudge(joint, amplitude, sp);
          await new Promise(res=>setTimeout(res, settleMs));
          await refresh();
          const peak = motors.find(m=>m.name===joi
