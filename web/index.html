<!-- Robot Arm Control v4.3.2 (rotations-correct: UI sends true rotations; no rotCal multiplication; rotation readouts use ABS) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lego Arm Control</title>
  <!-- Tailwind CDN for DEV. For production, compile Tailwind locally. -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { theme: { extend: { colors: {
      brand: { 25:"#f3f9ff",50:"#eaf3ff",100:"#d6e9ff",200:"#b6d9ff",300:"#8cc5ff",400:"#56aaff",500:"#1f90ff",600:"#1477db",700:"#0f5fb1",800:"#0c4d8f",900:"#0a3e75" }
    }}}};
  </script>
  <style>
    body { background: #f6f9fc; }
    .glass { background: rgba(255,255,255,0.18); border: 1px solid rgba(255,255,255,0.25); box-shadow: 0 8px 24px rgba(0,0,0,0.10); backdrop-filter: saturate(160%) blur(8px); }
    .soft-shadow { box-shadow: 0 14px 32px -8px rgba(2,132,199,.35); }
    .console-area { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .pressable { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; touch-action: none; }
    .no-select { -webkit-user-select: none; user-select: none; }
  </style>
</head>
<body class="antialiased text-slate-800">
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/qr-scanner@1.4.2/qr-scanner.umd.min.js"></script>

  <script type="text/babel">
    const {useEffect,useRef,useState,useMemo} = React;

    // ---------- Utils ----------
    const now = () => Date.now();
    const fmtMs = ms => (ms<1000? ms+'ms' : (ms/1000).toFixed(2)+'s');
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const join = (a,b) => {
      let s1 = String(a), s2 = String(b);
      while (s1.endsWith('/')) s1 = s1.slice(0,-1);
      while (s2.startsWith('/')) s2 = s2.slice(1);
      return s1 + '/' + s2;
    };
    const normalizeDeg = deg => ((deg + 180) % 360 + 360) % 360 - 180;
    const MOTOR_ORDER = ["A","B","C","D","E","F"];
    const DEFAULT_NUDGE_SPEEDS = {
      A: 60,
      B: 60,
      C: 60,
      D: 6,
      E: 60,
      F: 60,
    };
    const POS_ORDER = {
      A:["open","closed"],
      B:["min","pick","max"],
      C:["min","pick","max"],
      D:["assembly","neutral","quality"],
    };
    const cx = (...classes) => classes.filter(Boolean).join(' ');

    function useLocalStorage(key, initial){
      const [v,setV]=useState(()=>{ try { return JSON.parse(localStorage.getItem(key)) ?? initial; } catch { return initial; } });
      useEffect(()=>{ localStorage.setItem(key, JSON.stringify(v)); }, [key, v]);
      return [v,setV];
    }

    function percentile(arr,p){
      if(arr.length===0) return 0;
      const s=[...arr].sort((a,b)=>a-b);
      const idx = Math.min(s.length-1, Math.max(0, Math.floor((p/100)*(s.length-1))));
      return s[idx];
    }

    // ---------- UI primitives ----------
    const Icon = ({name, className="w-5 h-5"}) => ({
      menu: <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M4 6h16M4 12h16M4 18h16"/></svg>,
      copy: <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="9" y="9" width="13" height="13" rx="2" strokeWidth="2"/><path strokeWidth="2" d="M5 15V5a2 2 0 012-2h10"/></svg>,
      trash:<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M3 6h18M8 6V4h8v2M6 6l1 14h10l1-14"/></svg>,
      play: <svg className={className} viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>,
      pause:<svg className={className} viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="5" width="4" height="14"/><rect x="14" y="5" width="4" height="14"/></svg>,
      plus: <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M12 5v14M5 12h14"/></svg>,
      qr:<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M3 3h8v8H3zM13 3h8v8h-8zM3 13h8v8H3zM16 13h2v2h-2zM20 13h1v6h-1zM16 17h3v1h-3z"/></svg>,
      console:<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M4 6h16v12H4z"/><path strokeWidth="2" d="M7 10l3 2-3 2M13 14h4"/></svg>,
      target:<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="8" strokeWidth="2"/><circle cx="12" cy="12" r="2" strokeWidth="2"/></svg>,
      stop:<svg className={className} viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>,
      dl:  <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M12 3v12m0 0l-4-4m4 4 4-4M4 21h16"/></svg>,
      tune:<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor"><path strokeWidth="2" d="M4 6h10M14 6v10M4 18h16M8 18V8M18 6v8"/></svg>,
    }[name] || <span/>);

    const Btn = ({variant='primary', size='md', className='', children, ...props}) => {
      const sizes = {
        sm: 'px-2.5 py-1.5 text-sm rounded-lg',
        md: 'px-3 py-2.5 text-sm rounded-xl',
        lg: 'px-4 py-3 text-base rounded-xl',
        icon: 'w-14 h-14 rounded-full flex items-center justify-center'
      };
      const variants = {
        primary: 'bg-brand-600 hover:bg-brand-700 text-white border border-brand-700/20',
        secondary: 'bg-white hover:bg-slate-50 text-slate-700 border border-slate-200',
        ghost: 'bg-white/10 hover:bg-white/20 text-white border border-white/30',
        outline: 'bg-white text-slate-800 border border-slate-200',
        dark: 'bg-slate-800 text-white border border-slate-700',
        danger: 'bg-red-600 hover:bg-red-700 text-white border border-red-700/20',
      };
      return <button className={cx(sizes[size]||sizes.md, variants[variant]||variants.primary, className)} {...props}>{children}</button>;
    };

    const SectionHeader = ({title, subtitle, children}) => (
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-slate-800 font-semibold">{title}</h2>
          {subtitle && <div className="text-xs text-slate-500">{subtitle}</div>}
        </div>
        <div className="flex items-center gap-2">{children}</div>
      </div>
    );

    const Panel = ({title, subtitle, actions, children}) => (
      <section className="bg-white rounded-2xl shadow ring-1 ring-slate-100 p-4 sm:p-6">
        <SectionHeader title={title} subtitle={subtitle}>{actions}</SectionHeader>
        <div className="mt-4">{children}</div>
      </section>
    );

    const MotorPill = ({children, onClick}) => (
      <button onClick={onClick} className="glass inline-flex items-center gap-1 px-2 py-1 rounded-full text-white text-[11px] hover:bg-white/25 active:scale-[0.98] transition no-select">
        {children}
      </button>
    );

    const Sparkline = ({data, width=80, height=20, padding=2}) => {
      if(!data || data.length<2) return <svg width={width} height={height}></svg>;
      const min = Math.min(...data), max = Math.max(...data);
      const range = (max-min) || 1;
      const stepX = (width - 2*padding) / (data.length - 1);
      const pts = data.map((v,i)=>[padding + i*stepX, height - padding - ((v-min)/range)*(height-2*padding)]);
      const d = pts.map((p,i)=> (i===0? 'M':'L') + p[0].toFixed(1)+' '+p[1].toFixed(1)).join(' ');
      return <svg width={width} height={height}><path d={d} fill="none" stroke="currentColor" strokeWidth="1"/></svg>;
    };

    const DeltaGauge = ({delta, tol=1, size=68}) => {
      const r = (size/2)-6, cx=size/2, cy=size/2;
      const clamped = Math.abs(delta) > 90 ? 90 : Math.abs(delta);
      const angle = (clamped/90)*Math.PI;
      const x = cx + r*Math.cos(Math.PI - angle);
      const y = cy + r*Math.sin(Math.PI - angle);
      const path = `M ${cx-r} ${cy} A ${r} ${r} 0 0 1 ${x} ${y}`;
      const ok = Math.abs(delta) <= tol;
      return (
        <svg width={size} height={size} className="text-slate-300">
          <circle cx={cx} cy={cy} r={r} stroke="currentColor" strokeWidth="6" fill="none" opacity="0.25"/>
          <path d={path} stroke={ok?'#10b981':'#ef4444'} strokeWidth="6" fill="none" />
          <text x="50%" y="48%" dominantBaseline="middle" textAnchor="middle" fontSize="14" fill="#0f172a">{delta.toFixed(0)}°</text>
          <text x="50%" y="66%" dominantBaseline="middle" textAnchor="middle" fontSize="10" fill="#64748b">Δ</text>
        </svg>
      );
    };

    // ---------- App ----------
    function App(){
      // Single-robot config
      const [baseUrl, setBaseUrl] = useLocalStorage("ra.baseUrl", '');
      const [apiKey, setApiKey] = useLocalStorage("ra.apiKey", '');

      // Core state
      const [connected,setConnected]=useState(false);
      const [motors, setMotors] = useLocalStorage(
        "ra.motors",
        ["A","B","C","D"].map((n, i) => ({ id: i + 1, name: n, pos: 0 }))
      );
      const [logs,setLogs]=useLocalStorage("ra.logs",[]);
      const [inventory,setInventory]=useState(null);
      const [inventoryOpen,setInventoryOpen]=useState(false);
      const [adminOpen,setAdminOpen]=useState(false);
      const [qrOpen,setQrOpen]=useState(false);
      const [consoleOpen,setConsoleOpen]=useState(false);
      const [calibOpen,setCalibOpen]=useState(false);
      const [calibStatus,setCalibStatus]=useState({points:{},calibrated:false});
      const [backlash,setBacklash]=useState({A:0,B:0,C:0,D:0});
      const [nudgeSpeeds, setNudgeSpeeds] = useLocalStorage("ra.nudgeSpeeds", DEFAULT_NUDGE_SPEEDS);
      const [rotCal,setRotCal]=useState({A:360,B:360,C:360,D:360});
      const [lastDir,setLastDir]=useState({A:0,B:0,C:0,D:0});
      const [namedPoints,setNamedPoints]=useState({});
      const formattedPositions = useMemo(
        () =>
          motors
            .map(m => {
              const rot = (((m.abs ?? m.pos)) / (rotCal[m.name] || 360)).toFixed(2).replace('.', ',');
              return `${m.name}: ${rot} rot`;
            })
            .join('\n'),
        [motors, rotCal]
      );
      const formattedNamedPoints = useMemo(
        () => {
          const entries = Object.entries(namedPoints || {});
          if(entries.length===0) return 'No named points';
          return entries.map(([m,pts])=>{
            const inner = Object.entries(pts||{})
              .map(([n,v])=>`  ${n}: ${(+v).toFixed(1)}°`)
              .join('\n');
            return `${m}:\n${inner}`;
          }).join('\n');
        },
        [namedPoints]
      );

      const getMotorNudgeSpeed = (name) => {
        const fallback = DEFAULT_NUDGE_SPEEDS[name] ?? 60;
        const raw = Number(nudgeSpeeds?.[name]);
        if(Number.isFinite(raw) && raw > 0){
          return clamp(Math.round(raw), 1, 100);
        }
        return fallback;
      };

      useEffect(() => {
        setNudgeSpeeds(prev => {
          const base = prev && typeof prev === 'object' ? prev : {};
          const next = {...base};
          let changed = base !== prev;
          for(const m of motors){
            if(next[m.name] === undefined){
              next[m.name] = DEFAULT_NUDGE_SPEEDS[m.name] ?? 60;
              changed = true;
            }
          }
          const active = new Set(motors.map(m=>m.name));
          for(const key of Object.keys(next)){
            if(!active.has(key)){
              delete next[key];
              changed = true;
            }
          }
          if(!changed){
            return prev ?? base;
          }
          return next;
        });
      }, [motors, setNudgeSpeeds]);

      // Pill action menu (J/C/B) state
      const [pillMenu,setPillMenu]=useState({open:false, motor:null, x:0, y:0});
      const pillMenuRef = useRef(null);

      // Ring buffer (2 min)
      const RING_MS = 120000;
      const [ring,setRing]=useLocalStorage("ra.ring", []);

      // Soft limits
      const [limits,setLimits]=useLocalStorage("ra.limits", {
        A:{min:-9999,max:9999},
        B:{min:-9999,max:9999},
        C:{min:-9999,max:9999},
        D:{min:-9999,max:9999}
      });

      // Teach poses
      const [taught,setTaught]=useLocalStorage("ra.taught", {});
      const [targetPose,setTargetPose]=useLocalStorage("ra.targetPose", null);

      // Production processes
      const [processes,setProcesses]=useState([]);

      // Offline queue
      const [offlineQueue,setOfflineQueue]=useLocalStorage("ra.offlineQueue", []);

      // Jog modal
      const [jogMotor,setJogMotor]=useState(null); // {id,name,pos}
      const [jogEnable,setJogEnable]=useState(false);
      const repeatRef = useRef(null);
      const keyboardTimersRef = useRef({});
      const lastGamepadNudgeRef = useRef({A:0,B:0,C:0,D:0});
      const nudgeRef = useRef(()=>{});

      // Tilt-to-nudge (global permission; action gated by jogEnable + jogMotor)
      const [tiltEnabled,setTiltEnabled]=useState(false);
      const [tiltReady,setTiltReady]=useState(false);
      const [tiltGain,setTiltGain]=useLocalStorage("ra.tiltGain", 0.20);
      const [tiltBeta,setTiltBeta]=useState(0);
      const tiltZeroRef = useRef(0);
      const lastTiltTimeRef = useRef(0);

      // Custom
      const [customPath,setCustomPath]=useState("/v1/arm/move");
      const [customMethod,setCustomMethod]=useState("POST");
      const [customBody,setCustomBody]=useState('{"mode":"relative","joints":{"A":10},"speed":40}');
      const [nudgeUnit,setNudgeUnit]=useLocalStorage("ra.nudgeUnit","deg"); // 'deg' or 'rot'
      const [stepDeg,setStepDeg]=useLocalStorage("ra.stepDeg",5);
      const [stepRotRaw,setStepRotRaw]=useLocalStorage("ra.stepRot","1,0");
      const stepRotStr = String(stepRotRaw).replace('.', ',');
      const stepRot = parseFloat(stepRotStr.replace(',', '.')) || 0;
      const step = nudgeUnit==='deg' ? stepDeg : stepRot;
      const [timeoutOverride,setTimeoutOverride]=useLocalStorage("ra.nudgeTimeout", "");
      const [showAdvanced,setShowAdvanced]=useState(false);
      const [lastMoveSummary,setLastMoveSummary]=useState(null);
      const [toast,setToast]=useState(null);

      const polling = useRef(false);
      const alive = useRef(true);
      useEffect(()=>()=>{ alive.current=false; },[]);

      // Fetch calibration on load so values are always visible
      useEffect(()=>{
        api("GET","/v1/arm/backlash", undefined, {log:false})
          .then(d=>{
            setBacklash({A:0,B:0,C:0,D:0, ...(d?.backlash||{})});
            setLastDir({A:0,B:0,C:0,D:0, ...(d?.last_dir||{})});
          });
        api("GET","/v1/arm/rotation", undefined, {log:false})
          .then(d=>{
            setRotCal({A:360,B:360,C:360,D:360, ...(d?.rotation||{})});
          });
        fetchLastMoveSummary(false);
      },[]);

      // Pill menu outside click close
      useEffect(()=>{
        function onDocClick(e){
          if(!pillMenu.open) return;
          const el = pillMenuRef.current;
          if(el && !el.contains(e.target)){ setPillMenu({open:false, motor:null, x:0, y:0}); }
        }
        document.addEventListener('mousedown', onDocClick);
        return ()=>document.removeEventListener('mousedown', onDocClick);
      }, [pillMenu.open]);

      useEffect(()=>{
        if(!toast) return;
        const id=setTimeout(()=>setToast(null), 4000);
        return ()=>clearTimeout(id);
      }, [toast]);

      // --------- Logging helpers ---------
      const addLog = (e) => {
        const ts = new Date().toLocaleTimeString();
        setLogs(l=>[...l.slice(-999), {ts, ...e}]);
      };

      const headers = () => {
        const h={"Content-Type":"application/json","ngrok-skip-browser-warning":"1"};
        if(apiKey) h["x-api-key"]=apiKey;
        return h;
      };

      async function api(method, path, body, {timeoutMs=8000, queueIfOffline=false, log=true}={}){
        const url = join(baseUrl || "", path);
        if(queueIfOffline && !connected){
          const item={method,path,body,ts:now()}; setOfflineQueue(q=>[...q,item]);
          if(log) addLog({level:"ok",text:"Queued (offline): "+method+" "+url, body});
          return null;
        }
        const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(), timeoutMs);
        const opts={method, headers:headers(), signal:ctrl.signal};
        if(body!==undefined) opts.body=JSON.stringify(body);
        if(log) addLog({level:"req",text:`${method} ${url}`,body});
        const t0=performance.now();
        try{
          const res=await fetch(url, opts);
          const elapsed=Math.round(performance.now()-t0);
          const txt=await res.text(); let data=null; try{ data = txt ? JSON.parse(txt) : null; } catch {}
          if(log) addLog({level:res.ok?"ok":"err", text:`${res.status} ${res.statusText} (${elapsed}ms)`, body:(data??txt), ms:elapsed});
          if(!res.ok) throw new Error("HTTP "+res.status);
          return data?.data ?? data;
        } finally { clearTimeout(t); }
      }

      const parseNumber = (value) => {
        if(value === null || value === undefined) return null;
        const trimmed = String(value).trim();
        if(trimmed === "") return null;
        const normalized = trimmed.replace(',', '.');
        const num = Number.parseFloat(normalized);
        return Number.isFinite(num) ? num : null;
      };

      function summarizeMove(data, showToast=true){
        if(!data) return;
        setLastMoveSummary(data);
        if(!showToast) return;
        const unitLabel = data.units === 'rotations' ? 'rot' : 'deg';
        const commandedEntries = Object.entries(data.commanded || {});
        const commands = commandedEntries.map(([joint, val]) => {
          if(typeof val === 'number'){
            const formatted = data.units === 'rotations'
              ? `${val.toFixed(2).replace(/\.00$/, '')} ${unitLabel}`
              : `${val.toFixed(1)} ${unitLabel}`;
            return `${joint}: ${formatted}`;
          }
          return `${joint}: ${val}`;
        });
        const errors = Object.entries(data.final_error_deg || {})
          .map(([joint, val]) => `${joint} ${(+val).toFixed(1)}°`);
        const status = data.timeout ? 'timed out' : 'completed';
        const msg = `${commands.join(', ') || 'Move'} ${status}${errors.length ? ` • err ${errors.join(', ')}` : ''}`;
        setToast({text: msg, ts: Date.now(), timeout: !!data.timeout});
        addLog({level: data.timeout ? 'err' : 'ok', text: `Move summary: ${msg}`, body: data});
      }

      async function fetchLastMoveSummary(showToast=false){
        const data = await api("GET","/v1/arm/last_move", undefined, {log:false}).catch(()=>null);
        if(data){
          summarizeMove(data, showToast);
        }
        return data;
      }

      async function sendMove(payload, {queueIfOffline=true, log=true, fetchSummary=true}={}){
        const request = {...payload};
        if(request.async_exec === undefined){
          request.async_exec = false;
        }
        const res = await api("POST","/v1/arm/move", request, {queueIfOffline, log});
        if((fetchSummary ?? true) && res){
          if(res.new_abs){
            summarizeMove(res, true);
          } else if(res.operation_id){
            // queued async execution; summary will be available via operations polling
          } else {
            await fetchLastMoveSummary(true);
          }
        }
        return res;
      }

      async function moveDeg(name, degrees, speed=60, timeout_s=null, finalize=true){
        const joints={}; joints[name]=degrees;
        const payload={mode:"relative", units:"degrees", joints, speed, finalize};
        if(timeout_s !== null && timeout_s !== undefined){
          payload.timeout_s = timeout_s;
        }
        return sendMove(payload);
      }

      async function moveRot(name, rotations, speed=60, timeout_s=null, finalize=true){
        const joints={}; joints[name]=rotations;
        const payload={mode:"relative", units:"rotations", joints, speed, finalize};
        if(timeout_s !== null && timeout_s !== undefined){
          payload.timeout_s = timeout_s;
        }
        return sendMove(payload);
      }

      // Execute queued commands (explicit)
      async function runQueue(){
        if(!connected || offlineQueue.length===0) return;
        for(const item of offlineQueue){ await api(item.method, item.path, item.body).catch(()=>{}); }
        setOfflineQueue([]);
      }
      function clearQueue(){ setOfflineQueue([]); }

      async function saveBacklash(){
        try{ await api("POST","/v1/arm/backlash",backlash); addLog({level:"ok", text:"Saved backlash"}); }
        catch{ addLog({level:"err", text:"Failed to save backlash"}); }
      }

      async function saveRotation(){
        try{ await api("POST","/v1/arm/rotation",rotCal); addLog({level:"ok", text:"Saved rotation calibration"}); }
        catch{ addLog({level:"err", text:"Failed to save rotation calibration"}); }
      }

      // Calibration helpers
      async function fetchCalibration(){
        const d=await api("GET","/v1/arm/calibration",undefined,{log:false}).catch(()=>null);
        if(d) setCalibStatus(d);
      }
      async function setCalibPoint(joint,name){
        await api("POST","/v1/arm/calibration",{joint,name}).catch(()=>{});
        fetchCalibration();
      }
      async function finalizeCalibration(){
        const d=await api("POST","/v1/arm/calibration",{finalize:true}).catch(()=>null);
        if(d?.limits) setLimits(d.limits);
        if(d?.points) setCalibStatus({points:d.points, calibrated:true});
      }
      async function resetCalibration(){
        const d=await api("POST","/v1/arm/calibration",{reset:true}).catch(()=>null);
        if(d) setCalibStatus(d);
        setLimits({A:{min:-9999,max:9999},B:{min:-9999,max:9999},C:{min:-9999,max:9999},D:{min:-9999,max:9999}});
      }
      useEffect(()=>{ if(calibOpen) fetchCalibration(); },[calibOpen]);

      useEffect(()=>{
        if(adminOpen){
          api("GET","/v1/arm/backlash", undefined, {log:false})
            .then(d=>{
              setBacklash({A:0,B:0,C:0,D:0, ...(d?.backlash||{})});
              setLastDir({A:0,B:0,C:0,D:0, ...(d?.last_dir||{})});
            })
            .catch(()=>{});
          api("GET","/v1/arm/rotation", undefined, {log:false})
            .then(d=>{
              setRotCal({A:360,B:360,C:360,D:360, ...(d?.rotation||{})});
            })
            .catch(()=>{});
        }
      }, [adminOpen]);

      // Health & state polling
      async function checkHealth(verbose=false){
        try{ await api("GET","/v1/health", undefined, {log:verbose}); setConnected(true); }
        catch{ setConnected(false); }
      }

      async function updatePositions(verbose=false){
        if(polling.current) return;
        polling.current = true;
        try{
          const s = await api("GET","/v1/arm/state", undefined, {log:verbose});
          if(s?.abs_degrees){
            const ordered = Object.entries(s.abs_degrees)
              .map(([k,v])=>({name:k,pos:normalizeDeg(+v),abs:+v}))
              .sort((a,b)=>["A","B","C","D","E","F"].indexOf(a.name)-["A","B","C","D","E","F"].indexOf(b.name))
              .map((m,i)=>({id:i+1,...m}));
            setMotors(ordered);
            const sample = { t: now(), angles: Object.fromEntries(ordered.map(m=>[m.name, m.pos])) };
            setRing(prev => {
              const arr = [...prev, sample];
              const cutoff = now() - RING_MS;
              return arr.filter(s => s.t >= cutoff);
            });
            setNamedPoints(s.points || {});
          }
        } finally { polling.current=false; }
      }

      async function loadInventory(show=false){
        const inv = await api("GET","/v1/inventory").catch(()=>null);
        if(show && inv){ setInventory(inv); setInventoryOpen(true); }
        return inv;
      }

      async function refreshProcesses(){
        const inv = await api("GET","/v1/inventory").catch(()=>null);
        if(inv){ setProcesses(inv.processes || []); }
      }

      async function runProcess(name){
        if(!name) return;
        await api("POST", `/v1/processes/${name}`, {}, {queueIfOffline:true}).catch(()=>{});
      }

      async function sendPose(name, speed=60){
        if(!name) return;
        await api("POST","/v1/arm/pose", {name, speed}, {queueIfOffline:true});
      }

      async function gotoNamed(joint, name, speed=60){
        if(!joint || !name) return;
        const joints={}; joints[joint]=name;
        await sendMove({mode:"absolute", units:"degrees", joints, speed, finalize:true}).catch(()=>{});
      }

      async function sendCoast(motorNames, enable=true){
        const body = {enable};
        if(motorNames){ body.motors = Array.isArray(motorNames) ? motorNames : [motorNames]; }
        await api("POST","/v1/arm/coast", body, {queueIfOffline:true}).catch(()=>{});
      }

      async function stop(){ await api("POST","/v1/arm/stop",{reason:"ui stop"},{queueIfOffline:true}).catch(()=>{}); }

      async function handleStop(){
        addLog({level:'req', text:'Stop requested'});
        stopHoldRepeat();
        setJogEnable(false);
        await stop();
      }

      // ---- CORE NU D GE: sends *rotations* when unit is 'rot' (no rotCal math) ----
      async function nudge(name, amount, speed, options={}){
        const unit = options.unit || nudgeUnit;
        const finalize = options.finalize ?? true;
        const magnitude = Number(amount);
        if(!Number.isFinite(magnitude) || magnitude === 0){
          return;
        }
        const fallbackSpeed = getMotorNudgeSpeed(name);
        const requestedSpeed = Number(speed);
        const effectiveSpeed = Number.isFinite(requestedSpeed) && requestedSpeed > 0
          ? requestedSpeed
          : fallbackSpeed;
        const finalSpeed = clamp(effectiveSpeed, 1, 100);
        // Soft limit check in degrees (using 360° per rotation for preview)
        const lim = limits[name] || {min:-9999,max:9999};
        const current = normalizeDeg(motors.find(m=>m.name===name)?.pos ?? 0);
        const deltaDeg = unit === 'deg' ? magnitude : magnitude * 360; // preview only
        const next = normalizeDeg(current + deltaDeg);
        if(next < lim.min || next > lim.max){
          addLog({level:"err", text:`Soft limit ${name}: ${next.toFixed(1)}° out of [${lim.min}, ${lim.max}]`});
          return;
        }
        const manualTimeout = parseNumber(timeoutOverride);
        const manual = manualTimeout && manualTimeout > 0 ? manualTimeout : null;
        const chosenTimeout = options.timeout_s ?? manual ?? null;
        try{
          if(unit === 'deg'){
            await moveDeg(name, magnitude, finalSpeed, chosenTimeout, finalize);
          }else{
            await moveRot(name, magnitude, finalSpeed, chosenTimeout, finalize);
          }
        } catch (e) {
          return;
        }
        // optimistic UI update
        setMotors(p =>
          p.map(x =>
            x.name === name
              ? { ...x, pos: normalizeDeg(x.pos + deltaDeg), abs: (x.abs ?? x.pos) + deltaDeg }
              : x
          )
        );
      }

      useEffect(()=>{ nudgeRef.current = nudge; });

      async function refresh(verbose=false){ await updatePositions(verbose); }

      async function runTuner({joint="A", amplitude=5, speeds=[20,40,60,80], settleMs=350}){
        const results=[];
        for(const sp of speeds){
          const before = motors.find(m=>m.name===joint)?.pos ?? 0;
          await nudge(joint, amplitude, sp, {unit:'deg'});
          await new Promise(res=>setTimeout(res, settleMs));
          await refresh();
          const peak = motors.find(m=>m.name===joint)?.pos ?? before;
          await nudge(joint, -amplitude, sp, {unit:'deg'});
          await new Promise(res=>setTimeout(res, settleMs));
          await refresh();
          const after = motors.find(m=>m.name===joint)?.pos ?? before;
          const forwardErr = Math.abs((before+amplitude) - peak);
          const returnErr  = Math.abs(before - after);
          results.push({speed:sp, forwardErr, returnErr});
        }
        return results;
      }

      // ---- Diagnostics export ----
      function exportDiagnostics(){
        const blob = new Blob([JSON.stringify({
          ts: new Date().toISOString(),
          baseUrl,
          inventory,
          motors,
          ring,
          limits,
          taught,
          processes,
          logs: logs.slice(-200),
        }, null, 2)], {type:"application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href=url; a.download = 'robot_diagnostics.json';
        a.click();
        URL.revokeObjectURL(url);
      }

      // ---- Blend-to-pose helper ----
      function blendToPose(percent, speed=60){
        if(!targetAngles) return;
        const joints={};
        for(const m of motors){
          const tgt = targetAngles[m.name];
          if(typeof tgt !== 'number') continue;
          const delta = (tgt - m.pos) * (percent/100);
          if(Math.abs(delta)>=0.5) joints[m.name]=Math.round(delta);
        }
        if(Object.keys(joints).length){
          sendMove({mode:"relative", units:"degrees", joints, speed}).catch(()=>{});
        }
      }

      // ---- QR parser ----
      function parseQr(text){
        try {
          const j = JSON.parse(text);
          if(j.baseUrl) setBaseUrl(j.baseUrl);
          if(j.apiKey) setApiKey(j.apiKey);
          return;
        } catch {}
        const params = new URLSearchParams(text);
        if(params.get('baseUrl')) setBaseUrl(params.get('baseUrl'));
        if(params.get('apiKey')) setApiKey(params.get('apiKey'));
      }

      // Polling intervals & tab visibility
      useEffect(()=>{ checkHealth(); const id=setInterval(checkHealth,15000); return ()=>clearInterval(id); }, [baseUrl, apiKey]);
      useEffect(()=>{
        updatePositions();
        const id=setInterval(()=>{ if(!document.hidden) updatePositions(); }, 5000);
        const onVis = () => { if(!document.hidden) updatePositions(); };
        document.addEventListener("visibilitychange", onVis);
        return ()=>{ clearInterval(id); document.removeEventListener("visibilitychange", onVis); };
      }, [baseUrl, apiKey]);
      useEffect(()=>{ refreshProcesses(); }, [baseUrl, apiKey]);

      // ---------- Analytics ----------
      const series = useMemo(()=>{
        const names = Object.keys(motors.reduce((acc,m)=> (acc[m.name]=1, acc), {}));
        const byName = Object.fromEntries(names.map(n=>[n, []]));
        ring.forEach(s=>{ names.forEach(n=> byName[n].push({t:s.t, v: s.angles[n] ?? 0})) });
        return byName;
      }, [ring, motors]);

      const rates = useMemo(()=>{
        const r={};
        for(const [n,arr] of Object.entries(series)){
          if(arr.length<2){ r[n]=0; continue; }
          const a=arr[arr.length-2], b=arr[arr.length-1];
          const dt=(b.t-a.t)/1000; const dv=b.v-a.v; r[n]= dt? (dv/dt) : 0;
        }
        return r;
      }, [series]);

      const latencies = useMemo(()=> logs.filter(l=>typeof l.ms==='number').map(l=>l.ms), [logs]);
      const reliab = useMemo(()=>{
        const ok = logs.filter(l=>l.level==='ok').length;
        const err = logs.filter(l=>l.level==='err').length;
        const total = ok+err || 1;
        return { successRate: (ok/total)*100, p50: percentile(latencies, 50), p95: percentile(latencies, 95) };
      }, [logs, latencies]);

      const bins = useMemo(()=>{
        const B=18;
        const out={};
        for(const n of Object.keys(series)){
          const arr=new Array(B).fill(0);
          const values = series[n].map(x=>x.v);
          if(values.length){
            const min=Math.min(...values), max=Math.max(...values);
            for(const v of values){
              const idx = clamp(Math.floor(((v-min)/(max-min||1)) * (B-1)), 0, B-1);
              arr[idx]++;
            }
          }
          out[n]=arr;
        }
        return out;
      }, [series]);

      const targetAngles = useMemo(()=>{
        if(targetPose && taught[targetPose]) return taught[targetPose];
        return null;
      }, [targetPose, taught]);

      // ---------- Hold-to-repeat helpers ----------
      function holdNudgeStart(name, delta, unitOverride){
        if(repeatRef.current) return;
        const opts = unitOverride ? {unit: unitOverride} : {};
        nudge(name, delta, 60, opts);
        repeatRef.current = setInterval(()=> nudge(name, delta, 60, opts), 220);
      }
      function stopHoldRepeat(){
        if(repeatRef.current){ clearInterval(repeatRef.current); repeatRef.current=null; }
      }

      // ---------- Keyboard bindings (arrows + WASD) ----------
      useEffect(()=>{
        const timers = keyboardTimersRef.current;
        const pressed = new Set();
        const bindings = {
          ArrowLeft: {joint:"D", dir:-1},
          ArrowRight:{joint:"D", dir: 1},
          ArrowUp:   {joint:"A", dir: 1},
          ArrowDown: {joint:"A", dir:-1},
          KeyW:      {joint:"B", dir: 1},
          KeyS:      {joint:"B", dir:-1},
          KeyA:      {joint:"C", dir:-1},
          KeyD:      {joint:"C", dir: 1},
          w:         {joint:"B", dir: 1},
          s:         {joint:"B", dir:-1},
          a:         {joint:"C", dir:-1},
          d:         {joint:"C", dir: 1},
        };
        const stepFor = (joint, dir) => {
          const unit = nudgeUnit === 'deg' ? stepDeg : stepRot;
          if(!unit) return 0;
          return dir * unit;
        };
        const start = (keyId, cfg) => {
          if(!cfg || pressed.has(keyId)) return;
          const delta = stepFor(cfg.joint, cfg.dir);
          if(!delta) return;
          pressed.add(keyId);
          nudgeRef.current(cfg.joint, delta);
          timers[keyId] = setInterval(()=> nudgeRef.current(cfg.joint, delta), 200);
        };
        const stop = (keyId) => {
          pressed.delete(keyId);
          if(timers[keyId]){
            clearInterval(timers[keyId]);
            delete timers[keyId];
          }
        };
        const onKeyDown = (e) => {
          const keyId = e.code || e.key;
          const cfg = bindings[keyId] || bindings[e.key];
          if(!cfg) return;
          e.preventDefault();
          start(keyId, cfg);
        };
        const onKeyUp = (e) => {
          const keyId = e.code || e.key;
          if(bindings[keyId] || bindings[e.key]){
            stop(keyId);
          }
        };
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        return () => {
          window.removeEventListener('keydown', onKeyDown);
          window.removeEventListener('keyup', onKeyUp);
          Array.from(Object.keys(timers)).forEach(stop);
        };
      }, [nudgeUnit, stepDeg, stepRot]);

      // ---------- Gamepad (analog sticks) ----------
      useEffect(()=>{
        let raf = null;
        const bindings = [
          {axis:0, joint:"D", invert:false},
          {axis:1, joint:"C", invert:true},
          {axis:2, joint:"B", invert:false},
          {axis:3, joint:"A", invert:true},
        ];
        const poll = () => {
          try{
            const pads = typeof navigator !== 'undefined' && typeof navigator.getGamepads === 'function'
              ? navigator.getGamepads()
              : [];
            const pad = pads ? Array.from(pads).find(Boolean) : null;
            if(pad && pad.axes){
              const dead = 0.25;
              const nowTs = performance.now();
              bindings.forEach(({axis, joint, invert}) => {
                const raw = pad.axes[axis] ?? 0;
                const value = invert ? -raw : raw;
                if(Math.abs(value) <= dead) return;
                const last = lastGamepadNudgeRef.current[joint] || 0;
                if(nowTs - last < 150) return;
                const strength = (Math.abs(value) - dead) / (1 - dead);
                const unit = nudgeUnit === 'deg' ? stepDeg : stepRot;
                if(!unit) return;
                const delta = Math.sign(value) * strength * unit;
                if(Math.abs(delta) < 0.1) return;
                lastGamepadNudgeRef.current[joint] = nowTs;
                nudgeRef.current(joint, delta);
              });
            }
          } catch(e) {}
          raf = requestAnimationFrame(poll);
        };
        raf = requestAnimationFrame(poll);
        return () => {
          if(raf !== null){
            cancelAnimationFrame(raf);
          }
        };
      }, [nudgeUnit, stepDeg, stepRot]);

      // ---------- Tilt permission + handler ----------
      async function enableTilt(){
        try{
          const Any = window.DeviceOrientationEvent;
          if(Any && typeof Any.requestPermission === 'function'){
            const res = await Any.requestPermission();
            if(res !== 'granted'){ alert('Motion permission not granted'); setTiltReady(false); return; }
          }
          setTiltReady(true);
          setTiltEnabled(true);
        }catch(e){
          setTiltReady(true);
          setTiltEnabled(true);
        }
      }
      useEffect(()=>{
        if(!tiltEnabled) return;
        function onOrient(e){
          const b = (typeof e.beta === 'number') ? e.beta : 0; // -180..180
          setTiltBeta(b);
          if(!jogMotor || !jogEnable || !tiltReady) return;
          const deflection = b - tiltZeroRef.current;
          const scaled = clamp(deflection * tiltGain, -3, 3);
          const threshold = 0.45;
          const t = now();
          if(Math.abs(scaled) > threshold && (t - lastTiltTimeRef.current) > 160){
            lastTiltTimeRef.current = t;
            const step = scaled > 0 ? 1 : -1; // 1° nudge per tick
            nudge(jogMotor.name, step, 60, {unit:'deg'});
          }
        }
        window.addEventListener('deviceorientation', onOrient);
        return ()=> window.removeEventListener('deviceorientation', onOrient);
      }, [tiltEnabled, tiltReady, jogMotor, jogEnable, tiltGain, motors]);

      // ---------- Header subcomponents ----------
      const StatusPill = () => (
        <div className={cx(
          "inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-white text-slate-800 shadow-sm ring-1",
          connected ? 'ring-emerald-400 shadow-[0_0_8px_rgba(52,211,153,0.6)]' : 'ring-slate-200'
        )}>
          <span className={cx("w-2.5 h-2.5 rounded-full", connected ? 'bg-emerald-400 shadow-[0_0_6px_rgba(52,211,153,0.8)]' : 'bg-slate-300')}></span>
          <span className="font-semibold">{connected ? "Connected" : "Offline"}</span>
        </div>
      );

      // Keyboard emergency stop
      useEffect(()=>{
        function onKey(e){ if(e.key === 'Escape'){ handleStop(); } }
        window.addEventListener('keydown', onKey);
        return ()=>window.removeEventListener('keydown', onKey);
      }, []);

      // ----- Render -----
      return (
        <div className="min-h-screen relative">
          {toast && (
            <div className="fixed top-6 right-6 z-50">
              <div className={cx(
                "px-4 py-3 rounded-xl border shadow-lg text-sm font-medium",
                toast.timeout ? 'bg-red-50 border-red-200 text-red-700' : 'bg-white border-emerald-200 text-emerald-700'
              )}>
                {toast.text}
              </div>
            </div>
          )}
          {/* Header */}
          <header className="relative bg-gradient-to-b from-brand-600 to-brand-700 text-white soft-shadow overflow-visible">
            <div className="max-w-6xl mx-auto px-4 sm:px-6 pt-4">
              <div className="flex items-center justify-between gap-2">
                <h1 className="text-2xl font-semibold tracking-tight drop-shadow-sm">Lego Arm Control</h1>
                <div className="flex items-center gap-2">
                  <Btn variant="ghost" size="md" aria-label="Scan QR" title="Scan QR for config" onClick={()=>setQrOpen(true)}>
                    <Icon name="qr" />
                  </Btn>
                  <Btn variant="ghost" size="md" onClick={()=>setCalibOpen(true)} aria-label="Open calibration">
                    <Icon name="tune" /><span className="ml-2">Calibrate</span>
                  </Btn>
                  <Btn variant="ghost" size="md" onClick={()=>setAdminOpen(true)} aria-label="Open admin settings">
                    <Icon name="menu" /><span className="ml-2">Admin</span>
                  </Btn>
                </div>
              </div>
            </div>

            {/* Hero & stacked motor pills */}
            <div className="relative max-w-6xl mx-auto px-4 sm:px-6 h-[18rem] sm:h-[22rem]">
              <img src="robot-arm.png" alt="Robot Arm" className="absolute bottom-0 left-1/2 -translate-x-1/2 translate-y-[20%] pointer-events-none select-none max-h-[20rem] sm:max-h-[24rem] drop-shadow-[0_16px_36px_rgba(31,144,255,0.55)]" />
              <div className="absolute right-4 sm:right-6 top-1/2 -translate-y-1/2 flex flex-col gap-2 items-end">
                {motors.map(m => (
                  <MotorPill
                    key={m.id}
                    onClick={(e)=>{
                      const r = e.currentTarget.getBoundingClientRect();
                      setPillMenu({open:true, motor:m, x:r.left, y:r.bottom + 6});
                    }}
                  >
                    <span className="font-semibold">{m.name}</span>
                    <span className="opacity-90 ml-0.5">
                      {nudgeUnit==='deg'
                        ? Math.round(m.pos)+'°'
                        : (((m.abs ?? m.pos)/(rotCal[m.name]||360)).toLocaleString('de-DE',{minimumFractionDigits:1,maximumFractionDigits:2})+'r')}
                    </span>
                  </MotorPill>
                ))}
              </div>
            </div>
          </header>

          {/* Pill action popover (J / C / B) */}
          {pillMenu.open && pillMenu.motor && (
            <div
              ref={pillMenuRef}
              className="fixed z-50 bg-white rounded-xl shadow-xl border border-slate-200 p-2 flex items-center gap-2"
              style={{left: pillMenu.x + 'px', top: pillMenu.y + 'px'}}
            >
              <Btn size="sm" variant="dark" onClick={()=>{ setJogMotor(pillMenu.motor); setPillMenu({open:false, motor:null, x:0, y:0}); }} title="Jog">J</Btn>
              <Btn size="sm" variant="secondary" onClick={()=>{ sendCoast(pillMenu.motor.name, true); setPillMenu({open:false, motor:null, x:0, y:0}); }} title="Coast">C</Btn>
              <Btn size="sm" variant="secondary" onClick={()=>{ sendCoast(pillMenu.motor.name, false); setPillMenu({open:false, motor:null, x:0, y:0}); }} title="Brake">B</Btn>
            </div>
          )}

          {/* Status + queue */}
          <div className="max-w-6xl mx-auto px-4 sm:px-6 mt-6 relative z-10 flex items-center gap-3 flex-wrap">
            <StatusPill />
            {offlineQueue.length>0 ? (
              <div className="flex items-center gap-2">
                <Btn
                  variant={connected ? "secondary" : "outline"}
                  size="md"
                  onClick={connected ? runQueue : undefined}
                  disabled={!connected}
                  className={cx(!connected && "cursor-default")}
                >
                  {connected ? `Execute queued (${offlineQueue.length})` : `Queued (${offlineQueue.length})`}
                </Btn>
                <Btn variant="outline" size="md" onClick={clearQueue}>Clear</Btn>
              </div>
            ) : null}
          </div>

          {/* Main */}
          <main className="max-w-6xl mx-auto px-4 sm:px-6 pt-12 sm:pt-16 pb-28 space-y-6">
            <Panel title="General" subtitle="Quick actions">
              <div className="grid sm:grid-cols-6 gap-3">
                <Btn onClick={()=>sendPose("home")}>Home</Btn>
                <Btn variant="secondary" onClick={handleStop}>Stop</Btn>
                <Btn variant="secondary" onClick={()=>sendCoast(null,true)}>Coast all</Btn>
                <Btn variant="secondary" onClick={()=>checkHealth(true)}>Health</Btn>
                <Btn variant="secondary" onClick={()=>loadInventory(true)}>Inventory</Btn>
              </div>
            </Panel>

            <Panel title="Positions" actions={<Btn variant="outline" onClick={()=>refresh(true)}>Refresh</Btn>}>
              <pre className="bg-slate-100 rounded p-4 text-sm text-slate-800 whitespace-pre-wrap mb-4">{formattedPositions}</pre>
              <h4 className="font-semibold mb-1">Named points</h4>
              {Object.keys(namedPoints || {}).length ? (
                <div className="mb-4 space-y-2">
                  {motors.map(m=>{
                    const pts = namedPoints[m.name] || {};
                    const order = POS_ORDER[m.name] || Object.keys(pts);
                    return (
                      <div key={m.name}>
                        <div className="mb-1 flex items-center gap-2 font-medium">
                          <span>{m.name}</span>
                          <span className="text-xs text-slate-500">{m.pos.toFixed(1)}°</span>
                        </div>
                        <div className="flex flex-wrap gap-2">
                          {order.filter(p=>pts[p]!==undefined).map(p=>{
                            const v = pts[p];
                            const label = p === 'closed' ? 'close' : p;
                            return (
                              <div key={p} className="flex items-center gap-1">
                                <span className="text-xs text-slate-500">{(+v).toFixed(1)}°</span>
                                <Btn variant="secondary" size="sm" onClick={()=>gotoNamed(m.name,p)}>{label}</Btn>
                                <span className="text-xs text-slate-500">{(+v).toFixed(1)}°</span>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    );
                  })}
                </div>
              ) : (
                <div className="text-sm text-slate-500 mb-4">No named points.</div>
              )}
              <Btn onClick={()=>navigator.clipboard.writeText(formattedPositions+'\n'+formattedNamedPoints)}>
                <Icon name="copy"/><span className="ml-2">Copy</span>
              </Btn>
            </Panel>

            <Panel
              title="Telemetry & Targets"
              actions={
                <>
                  <select className="px-2 py-1 rounded-lg border border-slate-200" value={targetPose || ''} onChange={e=>setTargetPose(e.target.value || null)}>
                    <option value="">No target</option>
                    {Object.keys(taught).map(k=><option key={k} value={k}>{k}</option>)}
                  </select>
                  <Btn variant="outline" onClick={()=>{
                    const name = prompt("Save current as pose name:");
                    if(!name) return;
                    const angles = Object.fromEntries(motors.map(m=>[m.name, m.pos]));
                    setTaught({...taught, [name]: angles});
                    setTargetPose(name);
                  }}>
                    <Icon name="target"/><span className="ml-2">Save current as pose</span>
                  </Btn>
                </>
              }
            >
              <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-4">
                {motors.map(m=>{
                  const data = (series[m.name]||[]).map(s=>s.v).slice(-60);
                  const delta = targetAngles && typeof targetAngles[m.name]==='number' ? (targetAngles[m.name]-m.pos) : 0;
                  const dtheta = rates[m.name] || 0;
                  const arr = bins[m.name] || [0];
                  const maxv = Math.max(1, ...arr);
                  return (
                    <div key={m.name} className="border rounded-2xl p-3">
                      <div className="flex items-center justify-between">
                        <div className="font-semibold">{m.name}</div>
                        <div className="text-sm text-slate-500">
                          {nudgeUnit==='deg'
                            ? Math.round(m.pos)+'°'
                            : (((m.abs ?? m.pos)/(rotCal[m.name]||360)).toLocaleString('de-DE',{minimumFractionDigits:1,maximumFractionDigits:2})+'r')}
                        </div>
                      </div>
                      <div className="mt-2 flex items-center justify-between">
                        <div className="text-xs text-slate-600">dθ/dt: {dtheta.toFixed(2)}°/s</div>
                        <div className="text-xs text-slate-500">last {data.length}</div>
                      </div>
                      <div className="mt-1 text-slate-500"><Sparkline data={data}/></div>
                      {targetAngles && <div className="mt-3 flex items-center justify-center"><DeltaGauge delta={delta}/></div>}
                      <div className="mt-3">
                        <div className="flex gap-0.5">{arr.map((v,i)=>{
                          const alpha = v ? Math.min(1, 0.15 + v / maxv) : 0.08;
                          return <div key={i} className="h-2 w-3 rounded" style={{background:`rgba(31,144,255,${alpha})`}}></div>;
                        })}</div>
                      </div>
                    </div>
                  );
                })}
              </div>
              {targetAngles && (
                <div className="mt-4 flex items-center gap-3">
                  <label className="text-sm text-slate-700">Blend to target</label>
                  <input type="range" min="0" max="100" defaultValue="0" onChange={e=>blendToPose(+e.target.value)}/>
                </div>
              )}
            </Panel>

            <Panel
              title="Nudge controls"
              actions={
                <div className="flex items-center gap-2">
                  <span className="text-xs text-slate-600">Units</span>
                  <select className="px-3 py-2 rounded-xl bg-white border border-slate-200" value={nudgeUnit} onChange={e=>setNudgeUnit(e.target.value)}>
                    <option value="deg">Degrees</option>
                    <option value="rot">Rotations</option>
                  </select>
                  <span className="text-xs text-slate-600">Step</span>
                  {nudgeUnit==='deg' ? (
                    <select className="px-3 py-2 rounded-xl bg-white border border-slate-200" value={stepDeg}
                            onChange={e=>setStepDeg(parseFloat(e.target.value)||1)}>
                      <option value="1">1°</option>
                      <option value="2">2°</option>
                      <option value="5">5°</option>
                      <option value="10">10°</option>
                    </select>
                  ) : (
                    <input type="text" className="px-3 py-2 rounded-xl bg-white border border-slate-200 w-24" value={stepRotStr}
                           onChange={e=>setStepRotRaw(e.target.value)} />
                  )}
                  <Btn variant="secondary" size="sm" onClick={()=>setShowAdvanced(v=>!v)}>
                    {showAdvanced ? 'Hide advanced' : 'Advanced'}
                  </Btn>
                </div>
              }
            >
              <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-4">
                {motors.map(m => (
                  <div key={m.id} className="border rounded-2xl p-4">
                    <div className="flex items-center justify-between">
                      <div className="font-semibold">{m.name}</div>
                      <div className="text-sm text-slate-500">
                        {nudgeUnit==='deg'
                          ? Math.round(m.pos)+'°'
                          : (((m.abs ?? m.pos)/(rotCal[m.name]||360)).toLocaleString('de-DE',{minimumFractionDigits:1,maximumFractionDigits:2})+'r')}
                      </div>
                    </div>
                    <div className="mt-1 text-xs text-slate-400">Backlash {backlash[m.name] ?? 0}°</div>
                    <div className="mt-3 flex items-center gap-2">
                      <label className="text-xs text-slate-500 uppercase tracking-wide">Speed</label>
                      <input
                        type="number"
                        min="1"
                        max="100"
                        className="px-3 py-2 rounded-xl bg-white border border-slate-200 w-24"
                        value={getMotorNudgeSpeed(m.name)}
                        onChange={e => {
                          const numeric = Number(e.target.value);
                          const sanitized = Number.isFinite(numeric) && numeric > 0
                            ? clamp(Math.round(numeric), 1, 100)
                            : getMotorNudgeSpeed(m.name);
                          setNudgeSpeeds(prev => {
                            const next = {...prev};
                            if(next[m.name] === sanitized){
                              return prev;
                            }
                            next[m.name] = sanitized;
                            return next;
                          });
                        }}
                      />
                    </div>
                    <div className="mt-3 flex gap-2">
                      <Btn variant="secondary" className="w-full"
                           onClick={()=>nudge(m.name,-step,getMotorNudgeSpeed(m.name))}>
                        -{nudgeUnit==='deg'?stepDeg:stepRotStr}{nudgeUnit==='deg'?'°':'r'}
                      </Btn>
                      <Btn className="w-full"
                           onClick={()=>nudge(m.name,step,getMotorNudgeSpeed(m.name))}>
                        +{nudgeUnit==='deg'?stepDeg:stepRotStr}{nudgeUnit==='deg'?'°':'r'}
                      </Btn>
                      <Btn variant="dark" className="w-14" title="Jog with tilt" onClick={()=>setJogMotor(m)}>J</Btn>
                    </div>
                  </div>
                ))}
              </div>
              {showAdvanced && (
                <div className="mt-4 bg-slate-50 border border-slate-200 rounded-xl p-3">
                  <div className="text-xs text-slate-600 mb-2">Optional overrides</div>
                  <div className="flex flex-col sm:flex-row sm:items-center gap-2 text-sm">
                    <label className="text-xs text-slate-600">Timeout (s)</label>
                    <input
                      type="text"
                      className="px-3 py-2 rounded-xl bg-white border border-slate-200 w-32"
                      placeholder="auto"
                      value={timeoutOverride}
                      onChange={e=>setTimeoutOverride(e.target.value)}
                    />
                    <div className="text-xs text-slate-500">Blank = no software timeout. Provide one only if you need a software stop.</div>
                  </div>
                  {lastMoveSummary && (
                    <div className="mt-3 text-xs text-slate-600">
                      Last move err: {Object.entries(lastMoveSummary.final_error_deg || {}).map(([j,v])=>`${j} ${( +v).toFixed(1)}°`).join(', ') || 'n/a'}
                    </div>
                  )}
                </div>
              )}
            </Panel>

            <Panel title="Production processes" actions={<Btn variant="outline" onClick={refreshProcesses}>Refresh</Btn>}>
              {processes.length===0 ? (
                <div className="text-sm text-slate-600">No processes available.</div>
              ) : (
                <div className="grid md:grid-cols-2 gap-3">
                  {processes.map(name => (
                    <div key={name} className="border rounded-2xl p-3 flex items-center justify-between">
                      <div className="font-semibold">{name}</div>
                      <Btn onClick={()=>runProcess(name)}><Icon name="play"/><span className="ml-2">Run</span></Btn>
                    </div>
                  ))}
                </div>
              )}
            </Panel>

            <Panel title="Analytics" subtitle="Reliability & tuning">
              <div className="grid md:grid-cols-3 gap-4">
                <div className="border rounded-2xl p-3">
                  <div className="text-sm font-semibold">Reliability (session)</div>
                  <div className="mt-2 text-sm text-slate-700">Success: {reliab.successRate.toFixed(1)}%</div>
                  <div className="text-sm text-slate-700">P50 latency: {fmtMs(reliab.p50)}</div>
                  <div className="text-sm text-slate-700">P95 latency: {fmtMs(reliab.p95)}</div>
                </div>
                <div className="md:col-span-2 border rounded-2xl p-3">
                  <div className="flex items-center justify-between">
                    <div className="text-sm font-semibold">Speed vs Accuracy tuner</div>
                    <Btn variant="outline" onClick={async()=>{
                      const res = await runTuner({joint: motors[0]?.name || "A"});
                      alert("Tuner results: "+JSON.stringify(res));
                    }}>Run sweep</Btn>
                  </div>
                  <div className="text-xs text-slate-600 mt-1">Runs tiny ±5° test on first joint, measures forward/return error per speed.</div>
                </div>
              </div>
              <div className="mt-3">
                <Btn variant="outline" onClick={exportDiagnostics}><Icon name="dl"/><span className="ml-2">Export diagnostics</span></Btn>
              </div>
            </Panel>

            <Panel title="Custom request">
              <div className="grid sm:grid-cols-5 gap-3">
                <div>
                  <label className="block text-xs text-slate-600 mb-1">Method</label>
                  <select className="w-full px-3 py-2 rounded-xl bg-white border border-slate-200" value={customMethod} onChange={e=>setCustomMethod(e.target.value)}>
                    <option>GET</option><option>POST</option><option>PUT</option><option>PATCH</option><option>DELETE</option>
                  </select>
                </div>
                <div className="sm:col-span-2">
                  <label className="block text-xs text-slate-600 mb-1">Path</label>
                  <input className="w-full px-3 py-2 rounded-xl bg-white border border-slate-200" value={customPath} onChange={e=>setCustomPath(e.target.value)} />
                </div>
                <div className="sm:col-span-2">
                  <label className="block text-xs text-slate-600 mb-1">JSON body</label>
                  <textarea className="w-full px-3 py-2 rounded-xl bg-white border border-slate-200 h-[42px]" value={customBody} onChange={e=>setCustomBody(e.target.value)}></textarea>
                </div>
              </div>
              <div className="mt-3 flex gap-2">
                <Btn onClick={async()=>{
                  let body; try{ body = customBody ? JSON.parse(customBody) : undefined; } catch { alert("Invalid JSON body"); return; }
                  await api(customMethod, customPath, body, {queueIfOffline:true});
                }}>Send</Btn>
              </div>
            </Panel>
          </main>

          {/* Floating vertical buttons: Console (top) + Master Stop (bottom) */}
          <div className="fixed bottom-5 right-5 z-50 flex flex-col items-center gap-3">
            <Btn variant="dark" size="icon" aria-label="Open Console" title="Open Console" onClick={()=>setConsoleOpen(true)}>
              <Icon name="console" className="w-7 h-7" />
            </Btn>
            <Btn variant="danger" size="icon" aria-label="Master Stop" title="Master Stop (Esc)" onClick={handleStop}>
              <Icon name="stop" className="w-7 h-7" />
            </Btn>
          </div>

          <footer className="py-6 text-center text-xs text-slate-500">
            Built with React + Tailwind. Settings are saved locally.
            <div className="mt-1 text-slate-600">— <span className="font-semibold">Michiel Haegens</span> • SAP DM = <span className="font-semibold">Definitely Moving</span>.</div>
          </footer>

          {/* Inventory modal */}
          {inventoryOpen && (
            <div className="fixed inset-0 z-40 flex items-center justify-center" role="dialog" aria-modal="true" aria-labelledby="inv-title">
              <div className="absolute inset-0 bg-black/40" onClick={()=>setInventoryOpen(false)}></div>
              <div className="relative bg-white rounded-xl shadow-xl p-6 w-full max-w-md max-h-[80vh] overflow-auto">
                <div className="flex items-center justify-between mb-4">
                  <h3 id="inv-title" className="text-lg font-semibold text-slate-800">Inventory</h3>
                  <Btn variant="secondary" size="sm" onClick={()=>setInventoryOpen(false)}>Close</Btn>
                </div>
                {inventory ? (
                  <div className="text-sm text-slate-700 space-y-4">
                    {inventory.endpoints && (
                      <div>
                        <h4 className="font-semibold mb-1">Endpoints</h4>
                        <ul className="list-disc list-inside space-y-1">{inventory.endpoints.map((e,i)=>(<li key={i}>{e}</li>))}</ul>
                      </div>
                    )}
                    {inventory.poses && (
                      <div>
                        <h4 className="font-semibold mb-1">Poses</h4>
                        <ul className="list-disc list-inside space-y-1">{inventory.poses.map((p,i)=>(<li key={i}>{p}</li>))}</ul>
                      </div>
                    )}
                    {inventory.motors && (
                      <div>
                        <h4 className="font-semibold mb-1">Motors</h4>
                        <ul className="list-disc list-inside space-y-1">{inventory.motors.map((m,i)=>(<li key={i}>{m}</li>))}</ul>
                      </div>
                    )}
                  </div>
                ) : ( <div className="text-sm text-slate-500">No inventory data.</div> )}
              </div>
            </div>
          )}

          {/* Console modal */}
          {consoleOpen && (
            <div className="fixed inset-0 z-50">
              <div className="absolute inset-0 bg-black/40" onClick={()=>setConsoleOpen(false)}></div>
              <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 bg-white rounded-xl shadow-xl p-6 w-full max-w-3xl max-h-[85vh] overflow-auto">
                <div className="flex items-center justify-between mb-3">
                  <div className="flex items-center gap-2"><Icon name="console"/><h3 className="text-lg font-semibold">Console & Timeline</h3></div>
                  <div className="flex gap-2">
                    <Btn variant="outline" size="sm" onClick={()=>navigator.clipboard.writeText(JSON.stringify(logs,null,2))}><Icon name="copy"/><span className="ml-1 text-sm">Copy</span></Btn>
                    <Btn variant="outline" size="sm" onClick={()=>setLogs([])}><Icon name="trash"/><span className="ml-1 text-sm">Clear</span></Btn>
                    <Btn variant="secondary" size="sm" onClick={()=>setConsoleOpen(false)}>Close</Btn>
                  </div>
                </div>
                <div className="overflow-x-auto">
                  <div className="min-w-[520px]">
                    {logs.slice(-100).map((l,idx)=> (
                      <div key={idx} className="flex items-center gap-3 py-1 text-sm">
                        <div className={cx("w-2 h-2 rounded-full",
                          l.level==='err'?'bg-red-500': l.level==='ok'?'bg-emerald-500':'bg-sky-400')}></div>
                        <div className="text-slate-500 w-24 shrink-0">{l.ts}</div>
                        <div className="shrink-0 w-20 text-slate-500">{typeof l.ms==='number'? fmtMs(l.ms) : ''}</div>
                        <div className="text-slate-800">{l.text}</div>
                      </div>
                    ))}
                  </div>
                </div>
                <div className="console-area mt-3 bg-slate-950 text-slate-100 rounded-xl p-3 h-64 overflow-auto ring-1 ring-black/10">
                  {logs.length === 0 ? (<div className="text-slate-400">No logs yet. Actions will appear here.</div>) : (
                    logs.map((l, idx) => (
                      <div key={idx} className="whitespace-pre-wrap text-sm">
                        <span className="text-brand-300">{l.ts}</span>{" "}
                        <span className={{"req":"text-sky-300","ok":"text-emerald-300","err":"text-red-300"}[l.level] || ""}>{l.text}</span>
                        {l.body !== undefined ? (<pre className="text-xs text-slate-300 mt-1 mb-2 bg-slate-900/60 rounded p-2">
                          {typeof l.body === "string" ? l.body.slice(0,5000) : JSON.stringify(l.body, null, 2).slice(0,5000)}
                        </pre>) : null}
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>
          )}

          {/* QR Bootstrap */}
          {qrOpen && (
            <div className="fixed inset-0 z-50">
              <div className="absolute inset-0 bg-black/40" onClick={()=>setQrOpen(false)}></div>
              <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 bg-white rounded-xl shadow-xl p-6 w-full max-w-md">
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2"><Icon name="qr"/><h3 className="text-lg font-semibold">Scan QR</h3></div>
                  <Btn variant="secondary" size="sm" onClick={()=>setQrOpen(false)}>Close</Btn>
                </div>
                <video id="qr-video" className="w-full rounded border"></video>
                <div className="mt-3">
                  <Btn onClick={async()=>{
                    if(!window.QrScanner){ alert("QR library not loaded."); return; }
                    const video=document.getElementById('qr-video');
                    const scanner=new window.QrScanner(video, result=>{ parseQr(result?.data || result); scanner.stop(); setQrOpen(false); }, {highlightScanRegion:true});
                    await scanner.start();
                  }}>Start camera</Btn>
                </div>
              </div>
            </div>
          )}

          {/* Calibration Drawer */}
          {calibOpen && (()=>{
            const CALIB={
              A:[{label:'open',key:'open'},{label:'close',key:'closed'}],
              B:[{label:'min',key:'min'},{label:'pick',key:'pick'},{label:'max',key:'max'}],
              C:[{label:'min',key:'min'},{label:'pick',key:'pick'},{label:'max',key:'max'}],
              D:[{label:'assembly',key:'assembly'},{label:'neutral',key:'neutral'},{label:'quality',key:'quality'}],
            };
            const allSet=Object.entries(CALIB).every(([j,arr])=>arr.every(p=>calibStatus.points?.[j]?.[p.key]!==undefined));
            return (
            <div className="fixed inset-0 z-50 pointer-events-none">
              <div className="absolute inset-0 bg-black/40"></div>
              <aside className="absolute right-0 top-0 h-full w-full max-w-md bg-white shadow-xl p-6 flex flex-col gap-4 pointer-events-auto">
                <div className="flex items-center justify-between mb-2">
                  <h3 className="text-lg font-semibold text-slate-800">Calibration</h3>
                  <Btn variant="secondary" size="sm" onClick={()=>setCalibOpen(false)}>Close</Btn>
                </div>
                <div className="space-y-4 text-sm">
                  {Object.entries(CALIB).map(([joint,points])=>(
                    <div key={joint}>
                      <div className="font-semibold mb-1">Motor {joint}</div>
                      <div className="flex flex-wrap gap-2">
                        {points.map(p=>(
                          <Btn
                            key={p.key}
                            size="sm"
                            className={cx(calibStatus.points?.[joint]?.[p.key] && "opacity-50")}
                            onClick={()=>setCalibPoint(joint,p.key)}
                          >
                            {calibStatus.points?.[joint]?.[p.key]? `✔ ${p.label}` : p.label}
                          </Btn>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
                <div className="mt-2 flex gap-2">
                  <Btn variant="secondary" onClick={resetCalibration}>Reset</Btn>
                  <Btn disabled={!allSet} onClick={finalizeCalibration}>Finalize</Btn>
                </div>
              </aside>
            </div>);
          })()}

          {/* Admin Drawer */}
          {adminOpen && (
            <div className="fixed inset-0 z-50">
              <div className="absolute inset-0 bg-black/40" onClick={()=>setAdminOpen(false)}></div>
              <aside className="absolute right-0 top-0 h-full w-full max-w-md bg-white shadow-xl p-6 flex flex-col gap-2">
                <div className="flex items-center justify-between mb-2">
                  <h3 className="text-lg font-semibold text-slate-800">Admin</h3>
                  <Btn variant="secondary" size="sm" onClick={()=>setAdminOpen(false)}>Close</Btn>
                </div>
                <label className="block text-xs text-slate-600">Base URL</label>
                <input className="w-full px-3 py-2 rounded-xl bg-white border border-slate-200" placeholder="https://your-ngrok-url.example" value={baseUrl} onChange={e=>setBaseUrl(e.target.value)} />
                <label className="block text-xs text-slate-600 mt-2">API key (optional)</label>
                <input className="w-full px-3 py-2 rounded-xl bg-white border border-slate-200" placeholder="api key..." value={apiKey} onChange={e=>setApiKey(e.target.value)} />
                <div className="mt-3 flex gap-2">
                  <Btn onClick={()=>setAdminOpen(false)}>Save</Btn>
                  <Btn variant="secondary" onClick={()=>{ setBaseUrl(''); setApiKey(''); }}>Clear</Btn>
                </div>
                <div className="mt-5">
                  <div className="text-sm font-semibold mb-1">Tilt-to-nudge</div>
                  <div className="text-xs text-slate-600 mb-2">Press once to grant motion permission. Actual movement only happens while holding <span className="font-medium">Enable</span> inside a Jog panel.</div>
                  <div className="flex items-center gap-2 flex-wrap">
                    <Btn variant={tiltEnabled ? "primary" : "secondary"} onClick={enableTilt}>{tiltEnabled? 'Tilt enabled' : 'Enable tilt sensors'}</Btn>
                    <label className="text-sm">Gain <input type="number" className="border rounded px-2 py-1 w-24 ml-1" value={tiltGain} step="0.05" min="0.05" max="1.5" onChange={e=>setTiltGain(parseFloat(e.target.value)||0.05)}/></label>
                  </div>
                </div>
                <div className="mt-5">
                  <div className="text-sm font-semibold mb-1">Rotation calibration</div>
                  <div className="text-xs text-slate-600 mb-2">Degrees for one full rotation.</div>
                  {['A','B','C','D'].map(m=>(
                    <label key={m} className="flex items-center gap-2 mb-2">
                      <span className="w-4">{m}</span>
                      <input type="number" className="border rounded px-2 py-1 w-24" value={rotCal[m] ?? 360} onChange={e=>setRotCal({...rotCal,[m]:parseFloat(e.target.value)||0})} />
                      <Btn variant="secondary" size="sm" onClick={()=>moveRot(m, 1).catch(()=>{})}>Test</Btn>
                    </label>
                  ))}
                  <div className="mt-2">
                    <Btn onClick={saveRotation}>Save</Btn>
                  </div>
                </div>
                <div className="mt-5">
                  <div className="text-sm font-semibold mb-1">Backlash calibration</div>
                  <div className="text-xs text-slate-600 mb-2">Extra degrees added on direction change.</div>
                  {['A','B','C','D'].map(m=>(
                    <label key={m} className="flex items-center gap-2 mb-2">
                      <span className="w-4">{m}</span>
                      <input type="number" step="0.1" className="border rounded px-2 py-1 w-24" value={backlash[m] ?? 0} onChange={e=>setBacklash({...backlash,[m]:parseFloat(e.target.value)||0})} />
                      <span className="text-xs text-slate-500">last: {lastDir[m] ?? 0}</span>
                    </label>
                  ))}
                  <div className="mt-2">
                    <Btn onClick={saveBacklash}>Save</Btn>
                  </div>
                </div>
              </aside>
            </div>
          )}

          {/* Jog modal */}
          {jogMotor && (
            <div className="fixed inset-0 z-50 no-select" role="dialog" aria-modal="true" aria-labelledby="jog-title">
              <div className="absolute inset-0 bg-black/40" onClick={()=>{ setJogMotor(null); stopHoldRepeat(); setJogEnable(false); }}></div>
              <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 bg-white rounded-xl shadow-xl p-6 w-full max-w-sm">
                <div className="flex items-center justify-between mb-2">
                  <h3 id="jog-title" className="text-lg font-semibold">Jog {jogMotor.name}</h3>
                  <Btn variant="secondary" size="sm" onClick={()=>{ setJogMotor(null); stopHoldRepeat(); setJogEnable(false); }}>Close</Btn>
                </div>

                {/* Tilt indicator */}
                <div className="mt-2">
                  <div className="text-xs text-slate-600 mb-1 flex items-center justify-between">
                    <span>Tilt indicator {tiltEnabled ? (tiltReady ? '(ready)' : '(awaiting permission)') : '(disabled)'}</span>
                    <span className="font-mono">{(tiltBeta - tiltZeroRef.current).toFixed(1)}°</span>
                  </div>
                  <div className="h-3 rounded bg-slate-100 relative overflow-hidden">
                    <div className="absolute left-1/2 top-0 bottom-0 w-px bg-slate-300"></div>
                    {(() => {
                      const def = clamp((tiltBeta - tiltZeroRef.current), -15, 15);
                      const pct = (def / 30) * 100;
                      const left = 50 + Math.min(0, pct);
                      const width = Math.abs(pct);
                      const active = jogEnable && tiltEnabled && tiltReady;
                      return (
                        <div
                          className="absolute top-0 bottom-0 rounded"
                          style={{ left: left + '%', width: width + '%', background: active ? '#2563eb' : '#94a3b8', opacity: 0.9 }}
                        />
                      );
                    })()}
                  </div>
                  <div className="text-[11px] text-slate-500 mt-1">Bar grows with tilt. Auto-zero occurs when you press <span className="font-medium">Enable</span>.</div>
                </div>

                <div className="text-sm text-slate-600 mt-3">Hold <span className="font-medium">Enable</span> to jog by tilt. Use ±1° for discrete steps (no enable needed).</div>
                <div className="flex items-center justify-between my-3">
                  <Btn variant="secondary"
                    className="w-24 pressable"
                    onPointerDown={(e)=>{ e.preventDefault(); holdNudgeStart(jogMotor.name, -1, 'deg'); }}
                    onPointerUp={stopHoldRepeat}
                    onPointerCancel={stopHoldRepeat}
                    onPointerLeave={stopHoldRepeat}
                    onContextMenu={(e)=>e.preventDefault()}
                  >-1°</Btn>

                  <Btn
                    className={cx("w-24 pressable", jogEnable? 'bg-emerald-600 text-white' : '')}
                    variant={jogEnable? "primary" : "secondary"}
                    onPointerDown={(e)=>{ e.preventDefault(); e.stopPropagation(); tiltZeroRef.current = tiltBeta; setJogEnable(true); }}
                    onPointerUp={(e)=>{ e.preventDefault(); setJogEnable(false); }}
                    onPointerCancel={()=>setJogEnable(false)}
                    onPointerLeave={()=>setJogEnable(false)}
                    onContextMenu={(e)=>e.preventDefault()}
                    title="Hold to enable tilt jog"
                  >
                    Enable
                  </Btn>

                  <Btn
                    className="w-24 pressable"
                    onPointerDown={(e)=>{ e.preventDefault(); holdNudgeStart(jogMotor.name, +1, 'deg'); }}
                    onPointerUp={stopHoldRepeat}
                    onPointerCancel={stopHoldRepeat}
                    onPointerLeave={stopHoldRepeat}
                    onContextMenu={(e)=>e.preventDefault()}
                  >+1°</Btn>
                </div>

                <div className="mt-3 text-sm text-slate-700">Soft limits: [{(limits[jogMotor.name]?.min ?? -9999)}°, {(limits[jogMotor.name]?.max ?? 9999)}°]</div>
                <div className="mt-3 flex gap-2">
                  <input
                    type="number"
                    className="w-24 px-2 py-1 rounded border"
                    placeholder="min"
                    value={limits[jogMotor.name]?.min ?? ''}
                    onChange={e=>setLimits({...limits, [jogMotor.name]: {...(limits[jogMotor.name]||{}), min:+e.target.value}})}
                  />
                  <input
                    type="number"
                    className="w-24 px-2 py-1 rounded border"
                    placeholder="max"
                    value={limits[jogMotor.name]?.max ?? ''}
                    onChange={e=>setLimits({...limits, [jogMotor.name]: {...(limits[jogMotor.name]||{}), max:+e.target.value}})}
                  />
                </div>
                {!tiltEnabled && (
                  <div className="mt-3 text-xs text-amber-700 bg-amber-50 border border-amber-200 rounded px-2 py-1">
                    Tilt sensors are disabled. Enable them once in <span className="font-medium">Admin → Tilt-to-nudge</span>.
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
